
// The production credentials are only used on the main branch, when the build is triggered by code push or a human
// On branches, PR, or the daily rebuild, then tests are run, no deployment are executed, and the "non production" credentials are used
def CREDENTIAL_BASE_ID = 'ci-terraform'
if (env.BRANCH_NAME == 'main' && !currentBuild.getBuildCauses('hudson.triggers.TimerTrigger$TimerTriggerCause')) {
  CREDENTIAL_BASE_ID = 'production-terraform'
}

pipeline {
  triggers {
    // Build once per day if not a Pull Request or not a tag build
    cron(env.CHANGE_ID || env.TAG_NAME ? '' : '@daily')
  }

  agent {
    kubernetes {
      yaml """
apiVersion: v1
kind: Pod
spec:
  containers:
  - name: terraform
    image: jenkinsciinfra/terraform@sha256:5abf75840de08d6bbd27687ae787a02f5cce447fc3f69b5af2232deaeb5206a0 # https://github.com/jenkins-infra/docker-terraform/releases/tag/1.2.0
    command:
    - cat
    tty: true
"""
      defaultContainer('terraform')
    }
  }

  options {
    buildDiscarder(logRotator(numToKeepStr: '5'))
    timeout(time: 1, unit: 'HOURS')
    disableConcurrentBuilds()
  }

  environment {
    AWS_ACCESS_KEY_ID = credentials("${CREDENTIAL_BASE_ID}-access-key")
    AWS_SECRET_ACCESS_KEY = credentials("${CREDENTIAL_BASE_ID}-secret-key")
    // https://www.terraform.io/docs/cli/config/environment-variables.html#tf_in_automation
    TF_IN_AUTOMATION = '1'
    // https://www.terraform.io/docs/cli/config/environment-variables.html#tf_input
    TF_INPUT = '0'
    BACKEND_CONFIG_FILE = credentials("${CREDENTIAL_BASE_ID}-backend-config")
  }

  stages {
    stage('ðŸ§¹ Prepare Terraform Environment') {
      steps {
        sh 'make prepare'
      }
    }
    stage('ðŸ”Ž Validate Terraform Project') {
      steps {
        sh 'make validate'
      }
    }
    stage('âœ… Test Terraform Project') {
      when {
        // Do not run tests with the production credentials to avoid polluting production Terraform workspaces
        expression {
          return CREDENTIAL_BASE_ID != 'production-terraform'
        }
      }
      steps {
        sh 'make tests'
      }
    }
    stage('ðŸš€ Deploy Production') {
      when {
        // Only run on the main branch
        expression {
          return CREDENTIAL_BASE_ID == 'production-terraform'
        }
      }
      stages {
        stage('ðŸ¦… Generate Terraform Plan') {
          steps {
            sh 'make plan'
          }
        }
        stage('ðŸš¢  Shipping Changes') {
          // Pipeline is timeouted
          input {
            message "Should we apply these changes to production?"
            ok "ðŸš¢ Yes, ship it!"
          }
          steps {
            sh 'make deploy'
          }
        }
      }
    }
  }
}
